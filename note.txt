///////////////////////////////////////////HttpServer
 is the backbone supporting our application. It takes care of things like:
    • where should the application be listening for incoming requests?
    A TCP socket
    (e.g. 127.0.0.1:8000)? A Unix domain socket?
    • what is the maximum number of concurrent connections that we should allow? How many new
    connections per unit of time?
    • should we enable transport layer security (TLS)?
    • etc.
...HttpServer, in other words, handles all transport level concerns.

/////////////////////////////////////////////APP
...App is where all your application logic lives: routing, middlewares, request handlers, etc.
    App is the component whose job is to take an incoming request as input and spit out a response.

////////////////////////////////////////////ENDPOINTS/ ROUTES
route takes two parameters:
    • path, a string, possibly templated (e.g. "/{name}") to accommodate dynamic path segments;
    • route, an instance of the Route struct

 ////////////////////////////////////////////Rust's Asynchronous Model
Rust uses a "pull" model for async - futures are lazy and need to be "pulled" to make progress
Other languages (JavaScript, Python) use a "push" model - async tasks are actively scheduled
In Rust, a Future only progresses when something calls its poll() method

// This doesn't work directly:
async fn main() -> Result<(), std::io::Error> {
    // Async code here
}
The Solution: #[tokio::main] Macro
.What it does:
    The macro transforms your async main into a synchronous one that:
    Creates a Tokio runtime
    Runs your async code on it

///////
///////////////////////////Before Macro Expansion:
rust
#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    // Your async code
    server.run().await
}

////////////////////////////////After Macro Expansion (what actually gets compiled):

fn main() -> Result<(), std::io::Error> {
    // Wrap async code in a future
    let body = async move {
        // Your original async main body here
        server.run().await
    };
    
    // Create and run the Tokio runtime
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .expect("Failed building the Runtime")
        .block_on(body)  // This drives the future to completion
}

///////////////

...Before Macro Expansion:

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    // Your async code
    server.run().await
}

...After Macro Expansion (what actually gets compiled):

fn main() -> Result<(), std::io::Error> {
    // Wrap async code in a future
    let body = async move {
        // Your original async main body here
        server.run().await
    };
    
    // Create and run the Tokio runtime
    tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .expect("Failed building the Runtime")
        .block_on(body)  // This drives the future to completion
}


///////////////////////////////////Health Check Handler Example
.Original with warning:

async fn health_check(req: HttpRequest) -> impl Responder {
    HttpResponse::Ok()
}
// Warning: unused variable `req`
Fixed version:

async fn health_check() -> impl Responder {
    HttpResponse::Ok()
}
// actix-web is smart enough to accept handlers without request parameters

.......full pic.
use actix_web::{web, App, HttpResponse, HttpServer, Responder};

async fn health_check() -> impl Responder {
    HttpResponse::Ok()  // Returns 200 OK with empty body
}

 #[tokio::main] transforms this async main into sync code
#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    HttpServer::new(|| {
        App::new()
            .route("/health_check", web::get().to(health_check))
    })
    .bind("127.0.0.1:8000")?
    .run()
    .await
}

//////////////////////////////////////TESTING AN END POINT

////1. Embedded Tests (#[cfg(test)] mod tests)

// In your main code file (e.g., src/lib.rs or src/main.rs)
// fn my_private_function() -> u32 {
//     42
// }

// #[cfg(test)]  // Only compiled when running tests
// mod tests {
//     use super::*;  // Can access private items!
    
//     #[test]
//     fn test_private() {
//         assert_eq!(my_private_function(), 42);
//     }
// }

Key Points:

    Lives in same file as the code being tested
    Can test private functions and internals
    Part of the same binary
    Great for unit testing internal components

////2. External Tests (tests/ folder)

your_project/
├── src/
│   └── lib.rs    # Library code
└── tests/
    └── health_check.rs  # Integration test
.Key Points:

    Separate binaries
    Can only test public API
    Mimics how users would use your library
    Great for integration testing

////3. Documentation Tests (Doc Tests)

/// Adds two numbers together
/// 
/// ```
/// use my_crate::add;
/// assert_eq!(add(2, 2), 4);
/// ```
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
Key Points:

    Tests in documentation comments
    Verifies examples work
    Only tests public functions

////////////////////////////
Library crate: Contains all the logic
Binary crate: Thin wrapper that launches the library

...........................How tokio::spawn Works:

Test Thread
    ├── spawn_app()  // Starts server in background
    ├── HTTP Request // Tests run while server listens
    └── Test Assertions

Background Thread
    └── Server listening for requests

.Can't run tests in parallel (port conflict)
.Might conflict with other programs

...solution = port 0 magic

//////////////////DATABASE FORMAT FOR NAME AND EMAIL HANDLING
.if the name is Le Guin and the email is ursula_le_guin@gmail.com the POST request body
  should be name=le%20guin&email=ursula_le_guin%40gmail.com (spaces are replaced by %20 while @ becomes %40

• if a valid pair of name and email is supplied using the application/x-www-form-urlencoded format
the backend should return a 200 OK;
• if either name or email are missing the backend should return a 400 BAD REQUEST.

/////////////////
An extractor can be accessed as an argument to a handler function. Actix-web supports up to 10
extractors per handler function. Argument position does not matter.
Example:

use actix_web::web;
#[derive(serde::Deserialize)]
struct FormData {
username: String,
}
/// Extract form data using serde.
/// This handler get called only if content type is *x-www-form-urlencoded*
/// and content of the request could be deserialized to a `FormData` struct
fn index(form: web::Form<FormData>) -> String {
format!("Welcome {}!", form.username)
}

What are Extractors?
Extractors are middlemen that:

Look at incoming HTTP requests

Pull out specific information

Convert it to Rust types

Pass it to your handler function

Think of them as waiters at a restaurant:

Customer (HTTP request) comes in

Waiter (extractor) takes their order (extracts data)

Chef (your handler) gets clean, prepared ingredients (Rust structs)

Available Extractors:
rust
web::Path<T>    // Gets URL path parameters: /users/{id}
web::Query<T>   // Gets query string: ?name=John&age=30
web::Json<T>    // Gets JSON body
web::Form<T>    // Gets HTML form data (what we need!)
web::Data<T>    // Gets shared application data


Step 1: Define Your Data Structure
rust
#[derive(serde::Deserialize)]
struct FormData {
    email: String,
    name: String,
}
What this does:

Creates a Rust struct to hold form data

#[derive(serde::Deserialize)] = "Hey Rust, automatically generate code to convert form data into this struct"


Step 2: Use in Handler
rust
async fn subscribe(form: web::Form<FormData>) -> HttpResponse {
    // form.email and form.name are now available!
    println!("Email: {}", form.email);
    println!("Name: {}", form.name);
    
    HttpResponse::Ok().finish()
}
What happens:

User submits form → email=test@example.com&name=John

Actix-web sees web::Form<FormData> parameter

It calls Form::from_request() to extract data

Converts string to FormData struct

Passes it to your handler

////////////////////////////////
The Magic: FromRequest Trait
What is a Trait?
Think of it as an interface or contract:

"If you implement this trait, you promise to have these methods"

"If you have this trait, I know I can call these methods on you"

The FromRequest Contract:
rust
pub trait FromRequest {
    async fn from_request(
        req: &HttpRequest,
        payload: &mut Payload
    ) -> Result<Self, Error>;
}
Translation:

"If you want to be an extractor, you must:

Have a from_request method

It takes the HTTP request and its body

It returns either Self (your type) or an error"


What is Serde?
Serialization + Deserialization = Serde

It's a translation service between:

Rust types (structs, enums, etc.)

Various data formats (JSON, YAML, form data, etc.)

How Serde Works:
Imagine you're moving between countries:

Your Language	↔	Translation App	↔	Foreign Language
Rust Struct   	↔	Serde	       ↔	 JSON/Form/etc.
The Deserialize Trait:
rust
pub trait Deserialize<'de>: Sized {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>;
}
Translation:

"If you want to be deserializable, you must:

Have a deserialize method

It takes a deserializer (someone who understands the data format)

It returns either Self (your type) or an error"

Automatic Derivation:
rust
#[derive(serde::Deserialize)]
struct FormData {
    email: String,
    name: String,
}
This automatically generates code that says:

"To deserialize FormData, look for fields 'email' and 'name'"

"Convert their values to String type"


////////////////////////////////
The Complete Journey: Form Submission to Handler
Let's trace what happens step by step:

Step 0: User Action
text
User fills form → Clicks Submit
↓
POST /subscribe
Content-Type: application/x-www-form-urlencoded

email=test@example.com&name=John+Doe
Step 1: Actix-web Receives Request
rust
// Actix-web framework sees:
HttpRequest {
    method: POST,
    path: "/subscribe",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: "email=test@example.com&name=John+Doe"
}
Step 2: Route Matching
rust
// Our route definition:
.route("/subscribe", web::post().to(subscribe))

// Actix-web: "Oh, this goes to the `subscribe` handler!"
Step 3: Argument Inspection
rust
// Our handler signature:
async fn subscribe(form: web::Form<FormData>) -> HttpResponse

// Actix-web: "The handler needs a `web::Form<FormData>`...
//            I need to extract that from the request!"
Step 4: Extraction
rust
// Actix-web calls:
Form::from_request(request, payload)

// Which inside does:
// 1. Parse URL-encoded data
let raw_data = "email=test@example.com&name=John+Doe";

// 2. Use serde to convert to FormData
let form_data = serde_urlencoded::from_str::<FormData>(raw_data);
// Returns: FormData { email: "test@example.com", name: "John Doe" }

// 3. Wrap in Form type
Form(form_data)
Step 5: Handler Execution
rust
// Now your handler runs with the extracted data
async fn subscribe(form: web::Form<FormData>) -> HttpResponse {
    // form.0.email = "test@example.com"
    // form.0.name = "John Doe"
    HttpResponse::Ok().finish()
}

/////////////
how Serialize is implemented for a Rust vector:
use serde::ser::{Serialize, Serializer, SerializeSeq};
impl<T> Serialize for Vec<T>
where
T: Serialize,
{
fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
where
S: Serializer,
{
let mut seq = serializer.serialize_seq(Some(self.len()))?;
6
You can look at serde_json’s serialize_seq implementation for confirmation. There is an optimisation for empty sequences
(you immediately output []), but that is pretty much what is happening.50
CHAPTER 3. SIGN UP A NEW SUBSCRIBER
for element in self {
seq.serialize_element(element)?;
}
seq.end()
}
}


• before calling subscribe actix-web invokes the from_request method for all subscribe’s input ar-
guments: in our case, Form::from_request;
• Form::from_request tries to deserialise the body into FormData according to the rules of URL-
encoding leveraging serde_urlencoded and the Deserialize implementation of FormData, automat-
ically generated for us by #[derive(serde::Deserialize)];
• if Form::from_request fails, a 400 BAD REQUEST is returned to the caller. If it succeeds, subscribe
is invoked and we return a 200 OK.


src/
configuration.rs
lib.rs
main.rs
routes/
mod.rs
health_check.rs
subscriptions.rs
startup.rs
.////////////Our lib.rs file becomes


//! src/lib.rs
pub mod configuration;
pub mod routes;
pub mod startup;


startup.rs will host our run function, health_check goes into routes/health_check.rs, subscribe and
FormData into routes/subscriptions.rs, configuration.rs starts empty. Both handlers are re-exported
in routes/mod.rs:

.////////////! src/routes/mod.rs
mod health_check;
mod subscriptions;
pub use health_check::*;
pub use subscriptions::*;


Reading A Configuration File To manage configuration with config we must represent our
application settings as a Rust type that implements serde’s Deserialize trait.
Let’s create a new Settings struct:

//! src/configuration.rs
#[derive(serde::Deserialize)]
pub struct Settings {}